/* (c) 2019 Confio UO. Licensed under Apache-2.0 */

/* Generated with cbindgen:0.14.2 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

enum V3_ErrnoValue {
  V3_ErrnoValue_Success = 0,
  V3_ErrnoValue_Other = 1,
  V3_ErrnoValue_OutOfGas = 2,
};
typedef int32_t V3_ErrnoValue;

/**
 * This enum gives names to the status codes returned from Go callbacks to Rust.
 *
 * The go code will return one of these variants when returning.
 *
 */
enum V3_GoResult {
  V3_GoResult_Ok = 0,
  /**
   * Go panicked for an unexpected reason.
   */
  V3_GoResult_Panic = 1,
  /**
   * Go received a bad argument from Rust
   */
  V3_GoResult_BadArgument = 2,
  /**
   * Ran out of gas while using the SDK (e.g. storage)
   */
  V3_GoResult_OutOfGas = 3,
  /**
   * An error happened during normal operation of a Go callback, which should abort the contract
   */
  V3_GoResult_Other = 4,
  /**
   * An error happened during normal operation of a Go callback, which should be fed back to the contract
   */
  V3_GoResult_User = 5,
};
typedef int32_t V3_GoResult;

typedef struct V3_Buffer {
  uint8_t *ptr;
  uintptr_t len;
  uintptr_t cap;
} V3_Buffer;

typedef struct V3_cache_t {

} V3_cache_t;

/**
 * An opaque type. `*gas_meter_t` represents a pointer to Go memory holding the gas meter.
 */
typedef struct V3_gas_meter_t {
  uint8_t _private[0];
} V3_gas_meter_t;

typedef struct V3_db_t {
  uint8_t _private[0];
} V3_db_t;

typedef struct V3_iterator_t {
  uint64_t db_counter;
  uint64_t iterator_index;
} V3_iterator_t;

typedef struct V3_Iterator_vtable {
  int32_t (*next_db)(V3_iterator_t, V3_gas_meter_t*, uint64_t*, V3_Buffer*, V3_Buffer*, V3_Buffer*);
} V3_Iterator_vtable;

typedef struct V3_GoIter {
  V3_gas_meter_t *gas_meter;
  V3_iterator_t state;
  V3_Iterator_vtable vtable;
} V3_GoIter;

typedef struct V3_DB_vtable {
  int32_t (*read_db)(V3_db_t*, V3_gas_meter_t*, uint64_t*, V3_Buffer, V3_Buffer*, V3_Buffer*);
  int32_t (*write_db)(V3_db_t*, V3_gas_meter_t*, uint64_t*, V3_Buffer, V3_Buffer, V3_Buffer*);
  int32_t (*remove_db)(V3_db_t*, V3_gas_meter_t*, uint64_t*, V3_Buffer, V3_Buffer*);
  int32_t (*scan_db)(V3_db_t*, V3_gas_meter_t*, uint64_t*, V3_Buffer, V3_Buffer, int32_t, V3_GoIter*, V3_Buffer*);
} V3_DB_vtable;

typedef struct V3_DB {
  V3_gas_meter_t *gas_meter;
  V3_db_t *state;
  V3_DB_vtable vtable;
} V3_DB;

typedef struct V3_api_t {
  uint8_t _private[0];
} V3_api_t;

typedef struct V3_GoApi_vtable {
  int32_t (*humanize_address)(const V3_api_t*, V3_Buffer, V3_Buffer*, V3_Buffer*, uint64_t*);
  int32_t (*canonicalize_address)(const V3_api_t*, V3_Buffer, V3_Buffer*, V3_Buffer*, uint64_t*);
} V3_GoApi_vtable;

typedef struct V3_GoApi {
  const V3_api_t *state;
  V3_GoApi_vtable vtable;
} V3_GoApi;

typedef struct V3_querier_t {
  uint8_t _private[0];
} V3_querier_t;

typedef struct V3_Querier_vtable {
  int32_t (*query_external)(const V3_querier_t*, uint64_t, uint64_t*, V3_Buffer, V3_Buffer*, V3_Buffer*);
} V3_Querier_vtable;

typedef struct V3_GoQuerier {
  const V3_querier_t *state;
  V3_Querier_vtable vtable;
} V3_GoQuerier;

V3_Buffer V3_allocate_rust(const uint8_t *ptr, uintptr_t length);

V3_Buffer V3_create(V3_cache_t *cache, V3_Buffer wasm, V3_Buffer *err);

void V3_free_rust(V3_Buffer buf);

V3_Buffer V3_get_code(V3_cache_t *cache, V3_Buffer id, V3_Buffer *err);

V3_Buffer V3_handle(V3_cache_t *cache,
                    V3_Buffer code_id,
                    V3_Buffer params,
                    V3_Buffer msg,
                    V3_DB db,
                    V3_GoApi api,
                    V3_GoQuerier querier,
                    uint64_t gas_limit,
                    uint64_t *gas_used,
                    V3_Buffer *err);

V3_cache_t *V3_init_cache(V3_Buffer data_dir,
                          V3_Buffer supported_features,
                          uintptr_t _cache_size,
                          V3_Buffer *err);

V3_Buffer V3_instantiate(V3_cache_t *cache,
                         V3_Buffer contract_id,
                         V3_Buffer params,
                         V3_Buffer msg,
                         V3_DB db,
                         V3_GoApi api,
                         V3_GoQuerier querier,
                         uint64_t gas_limit,
                         uint64_t *gas_used,
                         V3_Buffer *err);

V3_Buffer V3_migrate(V3_cache_t *cache,
                     V3_Buffer contract_id,
                     V3_Buffer params,
                     V3_Buffer msg,
                     V3_DB db,
                     V3_GoApi api,
                     V3_GoQuerier querier,
                     uint64_t gas_limit,
                     uint64_t *gas_used,
                     V3_Buffer *err);

V3_Buffer V3_query(V3_cache_t *cache,
                   V3_Buffer code_id,
                   V3_Buffer msg,
                   V3_DB db,
                   V3_GoApi api,
                   V3_GoQuerier querier,
                   uint64_t gas_limit,
                   uint64_t *gas_used,
                   V3_Buffer *err);

/**
 * frees a cache reference
 *
 * # Safety
 *
 * This must be called exactly once for any `*cache_t` returned by `init_cache`
 * and cannot be called on any other pointer.
 */
void V3_release_cache(V3_cache_t *cache);
